# ORM Advanced Features - SQL Capture

> The `SQL` capture feature of the GoFrame framework works by intercepting SQL statements before they are submitted to the underlying database engine. It generates a human-readable string by combining the SQL statement template with the execution parameters, which is intended for reference and debugging purposes. It is important to note that the captured `SQL` statements are not the exact ones sent to the database engine. The captured `SQL` is the same as the `SQL` output by the ORM component when debugging mode is enabled; both are generated by the same component.

## CatchSQL

You can use the `gdb.CatchSQL` method to capture a list of `SQL` statements executed within a specified scope. The method is defined as follows:

```go
// CatchSQL catches and returns all sql statements that are EXECUTED in given closure function.
// Be caution that, all the following sql statements should use the context object passing by function `f`.
func CatchSQL(ctx context.Context, f func(ctx context.Context) error) (sqlArray []string, err error)
```

As you can see, this method executes SQL statements through a closure function. All SQL operations performed within this closure will be recorded and returned as a `[]string` type. Note that all SQL operations in the closure should pass the `ctx` context object; otherwise, the SQL statements will not be recorded.

**Example:**

**`user.sql`**

```sql
CREATE TABLE `user` (
    `id`          int(10) unsigned NOT NULL AUTO_INCREMENT,
    `passport`    varchar(45) NULL,
    `password`    char(32) NULL,
    `nickname`    varchar(45) NULL,
    `create_time` timestamp(6) NULL,
    PRIMARY KEY (id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

**`main.go`**

```go
package main

import (
    "context"

    _ "github.com/gogf/gf/contrib/drivers/mysql/v2"
    "github.com/gogf/gf/v2/database/gdb"
    "github.com/gogf/gf/v2/frame/g"
    "github.com/gogf/gf/v2/os/gctx"
    "github.com/gogf/gf/v2/os/gtime"
)

type User struct {
    Id         int
    Passport   string
    Password   string
    Nickname   string
    CreateTime *gtime.Time
}

func initUser(ctx context.Context) error {
    _, err := g.Model("user").Ctx(ctx).Data(User{
        Id:       1,
        Passport: "john",
        Password: "12345678",
        Nickname: "John",
    }).Insert()
    return err
}

func main() {
    var ctx = gctx.New()
    sqlArray, err := gdb.CatchSQL(ctx, func(ctx context.Context) error {
        return initUser(ctx)
    })
    if err != nil {
        panic(err)
    }
    g.Dump(sqlArray)
}
```

Output:

```bash
[
    "SHOW FULL COLUMNS FROM `user`",
    "INSERT INTO `user`(`id`,`passport`,`password`,`nickname`,`created_at`,`updated_at`) VALUES(1,'john','12345678','John','2023-12-19 21:43:57','2023-12-19 21:43:57') ",
]
```

## ToSQL

You can use the `gdb.ToSQL` method to convert a given SQL operation into an SQL statement without actually executing it. The method is defined as follows:

```go
// ToSQL formats and returns the last one of sql statements in given closure function
// WITHOUT TRULY EXECUTING IT.
// Be caution that, all the following sql statements should use the context object passing by function `f`.
func ToSQL(ctx context.Context, f func(ctx context.Context) error) (sql string, err error)
```

This method uses a closure function to estimate SQL statements. All SQL operations performed within this closure will be estimated, but only the last SQL statement will be returned as a string. Note that all SQL operations in the closure should pass the `ctx` context object; otherwise, the SQL statements will not be recorded.

**Example:**

**`user.sql`**

```sql
CREATE TABLE `user` (
    `id`          int(10) unsigned NOT NULL AUTO_INCREMENT,
    `passport`    varchar(45) NULL,
    `password`    char(32) NULL,
    `nickname`    varchar(45) NULL,
    `create_time` timestamp(6) NULL,
    PRIMARY KEY (id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

**`main.go`**

```go
package main

import (
    "context"

    _ "github.com/gogf/gf/contrib/drivers/mysql/v2"
    "github.com/gogf/gf/v2/database/gdb"
    "github.com/gogf/gf/v2/frame/g"
    "github.com/gogf/gf/v2/os/gctx"
    "github.com/gogf/gf/v2/os/gtime"
)

type User struct {
    Id         int
    Passport   string
    Password   string
    Nickname   string
    CreateTime *gtime.Time
}

func initUser(ctx context.Context) error {
    _, err := g.Model("user").Ctx(ctx).Data(User{
        Id:       1,
        Passport: "john",
        Password: "12345678",
        Nickname: "John",
    }).Insert()
    return err
}

func main() {
    var ctx = gctx.New()
    sql, err := gdb.ToSQL(ctx, func(ctx context.Context) error {
        return initUser(ctx)
    })
    if err != nil {
        panic(err)
    }
    g.Dump(sql)
}
```

Output:

```bash
"INSERT INTO `user`(`id`,`passport`,`password`,`nickname`,`created_at`,`updated_at`) VALUES(1,'john','12345678','John','2023-12-19 21:49:21','2023-12-19 21:49:21') "
```
