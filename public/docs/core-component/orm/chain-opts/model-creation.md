# ORM Chain Operation - Model Creation

## Model Creation

### Model

The `Model` method is used to create a `Model` object based on a data table. Additionally, you can use the `Model` method from the g object management module to create a `Model` object using the default database configuration.

***Example Usage***

```go
g.Model("user")
// or
g.DB().Model("user")
```

In some scenarios, you can also switch the current model's database object using the `DB` method:

```go
m := g.Model("user")
m = m.DB(g.DB("order"))
```

This has the same effect as:

```go
m := g.DB("user").Model("user")
```

### Raw

The `Raw` method is used to create a `Model` object based on raw SQL statements. You can also use the `ModelRaw` method from the g object management module to create a `Model` object with given SQL statements using the default database configuration.

***Example Usage***

```go
s := "SELECT * FROM `user`"
m, _ := g.ModelRaw(s).WhereLT("age", 18).Limit(10).OrderAsc("id").All()
// SELECT * FROM `user` WHERE `age`<18 ORDER BY `id` ASC LIMIT 10

s := "SELECT * FROM `user` WHERE `status` IN(?)"
m, _ := g.ModelRaw(s, g.Slice{1,2,3}).WhereLT("age", 18).Limit(10).OrderAsc("id").All()
// SELECT * FROM `user` WHERE `status` IN(1,2,3) AND `age`<18 ORDER BY `id` ASC LIMIT 10
```

## Chain Safety

Chain safety distinguishes between two modes of model operations: one that modifies the current `Model` object (unsafe, default) and one that does not (safe). To modify model attributes or add conditions, assignment operations are required.

### Default Behavior

By default, gdb is not chain-safe, meaning that each method call in a chain will modify the current `Model` attributes, making the `Model` object unsuitable for reuse. For instance, when using separate query conditions, you would use the `Model` object like this:

```go
user := g.Model("user")
user.Where("status", g.Slice{1,2,3})
if vip {
    // Query conditions automatically accumulate, modifying the current model object
    user.Where("money>=?", 1000000)
} else {
    // Query conditions automatically accumulate, modifying the current model object
    user.Where("money<?",  1000000)
}
// vip: SELECT * FROM user WHERE status IN(1,2,3) AND money >= 1000000
// !vip: SELECT * FROM user WHERE status IN(1,2,3) AND money < 1000000
r, err := user.All()
// vip: SELECT COUNT(1) FROM user WHERE status IN(1,2,3) AND money >= 1000000
// !vip: SELECT COUNT(1) FROM user WHERE status IN(1,2,3) AND money < 1000000
n, err := user.Count()
```

In this mode, each chain operation modifies the existing `Model` object, and the conditions will accumulate, making the `user` object unsuitable for reuse. Consequently, for each operation on the `user` table, you need to create a new `user` model object with `g.DB().Table("user")`, which can be cumbersome.

By default, to optimize performance and garbage collection, model objects are not chain-safe to prevent creating too many temporary model objects. (Smile)

Note that if you use DAO generated by the CLI tool `gen dao`, such as `user := dao.User.Ctx(ctx)`, the obtained `user` `Model` object is chain-safe by default (it has automatically called `.Safe()`).

### Clone

You can manually call the `Clone` method to clone the current model and create a new model to achieve chain safety. Since it is a new model object, there is no risk of modifying the existing model object.

***Example Usage***

```go
// Define a singleton user model
user := g.Model("user")
// Clone a new user model
m := user.Clone()
m.Where("status", g.Slice{1,2,3})
if vip {
    m.Where("money>=?", 1000000)
} else {
    m.Where("money<?",  1000000)
}
// vip: SELECT * FROM user WHERE status IN(1,2,3) AND money >= 1000000
// !vip: SELECT * FROM user WHERE status IN(1,2,3) AND money < 1000000
r, err := m.All()
// vip: SELECT COUNT(1) FROM user WHERE status IN(1,2,3) AND money >= 1000000
// !vip: SELECT COUNT(1) FROM user WHERE status IN(1,2,3) AND money < 1000000
n, err := m.Count()
```

### Safe

The `Safe` method can be used to set the current model as chain-safe. Each subsequent chain operation will return a new `Model` object, which can be reused. However, model attribute modifications or condition additions need to be performed through variable assignment (e.g., `m = m.xxx`) to replace the original model object.

***Example Usage***

```go
// Define a singleton user model
user := g.Model("user").Safe()
m := user.Where("status", g.Slice{1,2,3})
if vip {
    // Query conditions accumulated via assignment
    m = m.Where("money>=?", 1000000)
} else {
    // Query conditions accumulated via assignment
    m = m.Where("money<?",  1000000)
}
// vip: SELECT * FROM user WHERE status IN(1,2,3) AND money >= 1000000
// !vip: SELECT * FROM user WHERE status IN(1,2,3) AND money < 1000000
r, err := m.All()
// vip: SELECT COUNT(1) FROM user WHERE status IN(1,2,3) AND money >= 1000000
// !vip: SELECT COUNT(1) FROM user WHERE status IN(1,2,3) AND money < 1000000
n, err := m.Count()
```

In this mode, the `user` singleton object can be reused without concerns about being "polluted." With chain safety enabled, a singleton user object can be used for various queries. However, when multiple query conditions are present, conditions need to be added through model assignment operations (`m = m.xxx`).

> After marking with the `Safe` method, each chain operation will create a new temporary model object (internally using `Clone` to implement model cloning), achieving chain safety. This usage pattern is common in model operations.
