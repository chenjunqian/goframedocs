# Microservice - Project Management

## Basic Introduction

For microservice-based development, the project directory follows a unified framework structure. For more details, please refer to the section: [Project Directory Design](/docs/framework-design/project-package-design).

In this guide, we will use the project [https://github.com/gogf/gf-demo-grpc](https://github.com/gogf/gf-demo-grpc) as an example.

## Protocol Files

The protocol files are defined in the `manifest/protobuf` directory. The file path follows the pattern: `module_name/version/xxx.proto`, where the version number is managed in a format like `v1`, `v2`, etc., to ensure interface compatibility.

Additionally, the protocol files that involve the data table structures (generated by the framework's development tools) are stored in the `manifest/pbentity` directory.

## Interface Files

The interface files, which are generated from compiling the `.proto` files, are stored in the unified `api` directory.

## Development Tools

### Generating Data Table Structures

We can use the command `gf gen pbentity` or `make pbentity` to automatically generate corresponding protobuf protocol files based on the database table structures. For more details, please refer to the section: [PB-gen pbentity](/docs/development-tools/codegen/gen-pbentity).

### Compiling proto Files

The framework provides the commands `gf gen pb` or `make pb` to automatically compile the `.proto` files. These commands also generate the corresponding interface and controller files.

## Service Startup

The service startup control is still maintained through the `cmd` directory. For example, you can refer to the file: [https://github.com/gogf/gf-demo-grpc/blob/main/internal/cmd/cmd.go](https://github.com/gogf/gf-demo-grpc/blob/main/internal/cmd/cmd.go).

## Interface Implementation and Registration

Controllers are used to implement the interfaces defined in the `.proto` files. These controllers can be automatically generated, and the system will also generate the `Register` method, which is used to register the specific implementation into the service object.

***Registration Method***

The controller uses the generated `Register` method to bind the implementation to the gRPC server. This registration process ensures that the interfaces and their implementations are correctly mapped and ready for service.

```go
// Example of a generated registration method
func Register(s *grpc.Server) {
    api.RegisterYourServiceServer(s, &yourController{})
}
```

## Implementation and Registration of Interfaces

Controllers are used for the concrete implementation of interfaces defined by Proto files. Controllers can be generated automatically through commands and automatically generate the `Register` method, which is used to register the concrete implementation into the service object.

***Registration Method***

```go
func Register(s *grpcx.GrpcServer) {
    v1.RegisterUserServer(s.Server, &Controller{})
}

func (*Controller) Create(ctx context.Context, req *v1.CreateReq) (res *v1.CreateRes, err error) {
    _, err = dao.User.Ctx(ctx).Data(do.User{
        Passport: req.Passport,
        Password: req.Password,
        Nickname: req.Nickname,
    }).Insert()
    return
}
```

***Start Registration***

```go
package cmd

import (
    "context"
    "gf-demo-grpc/internal/logic"
    "gf-demo-grpc/internal/service"
    "github.com/gogf/gf/frame/g"
    "github.com/gogf/gf/net/grpcx"
)

var (
    Main = gcmd.Command {
        // Main is the main command.
        Name: "main",
        Brief: "start grpc server of simple goframe demos",
        Usage: "main",
        Func: func(ctx context.Context, parser *gcmd.Parser) (err error) {
            c := grpcx.Server.NewConfig()
            c.Options = append(c.Options, []grpc.ServerOption{
                grpc.WithUnaryServerInterceptor(grpcx.Server.UnaryValidate),
            }...)

            s := grpcx.Server.New(c)
            user.Register(s)

            s.Run()
            return nil
        },
    }
)
```

## Tag Injection and Data Validation

### Automatic Tag Injection

When using the `gf gen pb/make pb` command to compile proto files, it supports automatic tag injection. You only need to write the annotations in the proto file, and these annotations will automatically be embedded as `dc` tags in the struct properties. If the annotation format is like `xxx:yyy`, it will automatically generate the `xxx` tag.

For example:

```go
syntax = "proto3";

package user;

import "github.com/gogf/gf/contrib/protobuf/gogoproto/gogo.proto";

message GetOneReq {
    uint64 Id = 1 [(gogoproto.jsontag) = "id"];
}

message GetOneRes {
    entity.User User = 1 [(gogoproto.jsontag) = "user"]];
}

message GetListReq {
    int32 Page = 1 [(gogoproto.jsontag) = "page"];
    int32 Size = 2 [(gogoproto.jsontag) = "size"];
}

message GetListRes {
    repeated entity.User Users = 1 [(gogoproto.jsontag) = "users"]];
}

message CreateReq {
    string Passport = 1 [(gogoproto.jsontag) = "passport"];
    string Password = 2 [(gogoproto.jsontag) = "password"];
    string Nickname = 3 [(gogoproto.jsontag) = "nickname"];
}

message CreateRes {
}

message DeleteReq {
    uint64 Id = 1 [(gogoproto.jsontag) = "id"];
}

message DeleteRes {
}
```

```go
type CreateReq struct {
    // protobuf字段定义
    Passport string `protobuf:"bytes,1,opt,name=Passport,proto3" json:"Passport,omitempty"`
    Nickname string `protobuf:"bytes,3,opt,name=Nickname,proto3" json:"Nickname,omitempty"`
    Password string `protobuf:"bytes,2,opt,name=Password,proto3" json:"Password,omitempty"`
    // 其他字段
    unknownFields protoimpl.UnknownFields
    sizeCache      protoimpl.SizeCache
    state          protoimpl.MessageState
}
```

The above comments will automatically generate `json` tags for the Go struct.

***Note***

In the GRPC protocol, since both input and output are in the form of structs, it is not possible to achieve the default value feature like in HTTP services.

### Data Validation Plugin

The data validation plugin will automatically validate the request according to the rules set in the tags. It needs to be manually introduced on the server side in the form of an interceptor:

```go
var Main = gcmd.Command{
    Name: "main",
    Brief: "start grpc server of simple goframe demos",
    Usage: "main",
    Func: func(ctx context.Context, parser *gcmd.Parser) (err error) {
        c := grpcx.Server.NewConfig()
        c.Options = append(c.Options, ...)
        s := grpcx.Server.New(c)
        user.Register(s)
        return s.Run()
    },
}
```
