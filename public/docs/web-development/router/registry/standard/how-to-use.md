# Standard Routing - How to Use

## Route Method Definition

From the example above, we can see that the route method definition uses a fixed format:

```go
func Handler(ctx context.Context, req *Request) (res *Response, err error)
```

The input and output parameters are two, and both are mandatory, neither can be omitted. A brief introduction:

- `ctx context.Context`: The context is automatically retrieved from the request by the `Server` component and passed to the interface method.
- `req *Request`: The request object. Even if there are no received parameters, it must be defined because the request structure contains not only the definition of request parameters but also the request definition of the interface.
- `res *Response`: The response object. Even if there are no return parameters, it must be defined because the response structure contains not only the definition of return parameters but also the return definition of the interface.
- `err error`: The error object. The `Server` uses this parameter to determine whether the interface execution is successful or failed.

## Unified Route Registration

### Group.Bind Method

We recommend managing all route methods in an object-oriented manner and registering them through the Bind method of group routing. It should be noted that under the standard routing method, the route address and request method will be defined by the request structure in the `g.Meta` metadata object through tags. Group routing can define the prefix for all routes under the group.

### BindHandler Method

We can also register standard routes through the basic `BindHandler` method, but this method can only register one route function at a time. Usage example:

```go
s := g.Server()
s.BindHandler("/user/{uid}", func(ctx context.Context, req *SaveReq) (res *SaveRes, err error) {
    // ...
})
```

## Standard Parameter Structure

In standardized route registration, the definition of request/return parameter structures is very important. This structure contains not only the definition of input parameters but also the definition of the interface, especially route addresses, request methods, interface descriptions, and other information. Maintaining the data structure parameters through the structure facilitates richer interface capability expansion, team interaction, long-term interface maintenance, and automated interface documentation generation.

To ensure standardized naming, input data structures are named in the `XxxReq` format, and output data structures are named in the `XxxRes` format. Even if the input or output parameters are empty, the corresponding data structures must be defined. This is for easy future expansion and interface information management. For more information on the tags involved in the `OpenAPIv3` protocol within the structure, please refer to later sections.

> Request parameters are automatically converted to request data structures, and field mapping conversion is case-insensitive and automatically ignores special characters.

## Input Data Validation

The request structure will be automatically validated before entering the `API` interface execution. If one of the rules fails, the subsequent rule validation will be terminated (the built-in `bail` validation modifier rule is used automatically). The validation function uses the unified validation component of the framework. For more details, please refer to: [Data Validation](/docs/core-component/data-valid/).

> It requires special attention: If there are multiple validation rules for parameter validation, and if there is a `required*` rule, it is recommended to place the `required*` validation rule before all other rules. Otherwise, the characteristic of the built-in `bail` validation rule in the standard route (validation failure stops subsequent validation) may cause the subsequent rules' `required*` rules to not take effect.

## Unified Return Middleware

The data return processing of the interface needs to set a ***unified post middleware***, and of course, you can also use the data return middleware provided by the `Server` by default. When developers customize middleware, they can refer to the default middleware `MiddlewareHandlerResponse` provided by the `Server`.

By the way, when customizing the return middleware, an important method:

```go
// GetHandlerResponse retrieves and returns the handler response object and its error. 
func (r *Request) GetHandlerResponse() interface{} 
```

During the execution of the post middleware, the current business execution result is obtained through the `GetHandlerResponse` method of the request object, and corresponding processing is done as needed.

## Extended Introduction

### OpenAPIv3 Protocol

The interface documentation automatically generated by the `Server` component uses the latest `OpenAPIv3` protocol. For more information, please refer to the section: [Interface Documentation](/public/docs/web-development/router/interface-doc).

### Request Object in Ctx

We can obtain the Request object from `ctx` through the `RequestFromCtx`/`g.RequestFromCtx` method.

Method definition:

```go
func RequestFromCtx(ctx context.Context) *Request
```

Usage example:

```go
func (c *cHello) Hello(ctx context.Context, req *apiv1.HelloReq) (res *apiv1.HelloRes, err error) {
    g.RequestFromCtx(ctx).Response.Writeln("Hello World!")
    return
}
```
